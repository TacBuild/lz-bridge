#include "stdlib.fc";

;; =============== general consts =============================

const ONE_TON = 1000000000; ;; 1 TON
const TEN_TO_9_POWER = 1000000000;

;; jetton wallet ops
const JETTON_WALLET_OP::TRANSFER = 0xf8a7ea5;

;; errors
const int ERROR::NOT_ENOUGH_GAS = 48;

const ERROR::NOT_ENOUGH_TON = 100;
const ERROR::INSUFFICIENT_BALANCE = 101;

const ERROR::NOT_BOUNCEABLE_OP = 150;

;; =============== send msg utils =============================

() send_msg(slice to_address, int amount, cell payload, int flags, int send_mode) impure inline {
    int has_payload = ~ cell_null?(payload);

    var msg = begin_cell()
    .store_msg_flags_and_address_none(flags)
    .store_slice(to_address)
    .store_coins(amount)
    .store_uint(has_payload ? 1 : 0, MSG_ONLY_BODY_SIZE);

    if (has_payload) {
        msg = msg.store_ref(payload);
    }

    send_raw_message(msg.end_cell(), send_mode);
}

() send_jettons(slice jetton_wallet_address, int query_id, slice to_owner_address, int jetton_amount, slice response_address, int fwd_amount, cell forward_payload) impure inline {
    int has_fwd_payload = false;
    if (fwd_amount != 0) {
        has_fwd_payload = ~ cell_null?(forward_payload);
    }

    var msg_payload = begin_cell()
    .store_op_and_query_id(JETTON_WALLET_OP::TRANSFER, query_id)
    .store_coins(jetton_amount)
    .store_slice(to_owner_address)
    .store_slice(response_address)
    .store_uint(0, 1)
    .store_coins(fwd_amount)
    .store_uint(has_fwd_payload == 0 ? 0 : 1, 1);

    if (has_fwd_payload) {
        msg_payload = msg_payload.store_ref(forward_payload);
    }

    send_msg(jetton_wallet_address, 0, msg_payload.end_cell(), FLAGS::NON_BOUNCEABLE, SEND_MODE::BOUNCE_ON_ACTION_FAIL | SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE);
}


;; =============== logs utils =============================
() emit_log(int event_id, cell data, int need_separate_cell) impure inline {
    ;; 1023 - (4+2+9+256+64+32+2) = 654 bit free

    var msg = begin_cell()
    .store_uint (12, 4)         ;; ext_out_msg_info$11 src:MsgAddressInt ()
    .store_uint (1, 2)          ;; addr_extern$01
    .store_uint (256, 9)        ;; len:(## 9)
    .store_uint(event_id, 256); ;; external_address:(bits len)

    if (need_separate_cell) {
        msg = msg.store_uint(1, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either
        .store_ref(data);
    } else {
        msg = msg.store_uint(0, 64 + 32 + 2) ;; created_lt, created_at, init:Maybe, body:Either
        .store_slice(data.begin_parse());
    }

    send_raw_message(msg.end_cell(), SEND_MODE::REGULAR | SEND_MODE::BOUNCE_ON_ACTION_FAIL);
}

;; =============== calculate address utils =============================

slice calculate_address_by_state_init(int workchain, cell state_init) inline {
    {-
    https://github.com/ton-blockchain/ton/blob/8a9ff339927b22b72819c5125428b70c406da631/crypto/block/block.tlb#L105
    addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:bits256  = MsgAddressInt;
    -}
    return begin_cell()
    .store_uint(4, 3) ;; 0b100 = addr_std$10 tag; No anycast
    .store_int(workchain, 8)
    .store_uint(cell_hash(state_init), 256)
    .end_cell()
    .begin_parse();
}

slice calculate_basechain_address_by_state_init(cell state_init) inline {
    return calculate_address_by_state_init(BASECHAIN, state_init);
}
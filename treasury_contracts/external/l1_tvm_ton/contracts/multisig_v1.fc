;; =============== Multisig =============================

#include "imports/stdlib.fc";
#include "imports/utils.fc";
#pragma version >=0.4.0;

;; =============== consts =============================

const MIN_TON_FOR_INTERNAL = 20000000; ;; 0.02 TON
const MIN_TON_FOR_STORAGE = 200000000; ;; 0.2 TON

;; time
const TIME::MAX_DELAY_FOR_QUERY_ID = 24 * 60 * 60; ;; 24h

const MAX_FLOOD = 3;

const ANYONE_OP::CLEANUP = 0x26deb7ab;
const ANYONE_OP::EXCESSES = 0xd53276db;

;; errors
const ERROR::SENDER_PUBLIC_KEY_NOT_FOUND = 31;
const ERROR::INVALID_SENDER_SIGNATURE = 32;
const ERROR::WALLET_ID_DOES_NOT_MATCH = 33;
const ERROR::QUERY_HAS_ALREADY_BEEN_COMPLETED = 34;
const ERROR::INVALID_QUERY_ID = 35;
const ERROR::NOT_ALL_OWNERS_CONFIRMED = 36;
const ERROR::PUBLIC_KEY_NOT_FOUND = 37;
const ERROR::INVALID_SIGNATURE = 38;
const ERROR::ALREADY_SIGNED = 39;
const ERROR::QUERY_NOT_ACTIVE = 40;
const ERROR::MSG_DOESNT_MATCH = 41;
const ERROR::INVALID_REF_FORMAT = 42;
const ERROR::INVALID_MESSAGE_FORMAT = 43;
const ERROR::EXCEEDED_MAX_FLOOD = 44;


;; global
global int wallet_id;
global int n;
global int k;
global cell owner_infos;
global cell pending_queries;


;; =============== storage =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    wallet_id = ds~load_uint(32);
    n = ds~load_uint(8);
    k = ds~load_uint(8);
    owner_infos = ds~load_dict();
    pending_queries = ds~load_dict();
}

() save_data() impure inline {
    set_data(begin_cell()
        .store_uint(wallet_id, 32)
        .store_uint(n, 8)
        .store_uint(k, 8)
        .store_dict(owner_infos)
        .store_dict(pending_queries)
        .end_cell()
    );
}


;; =============== storage utils =============================

_ pack_owner_info(int public_key, int flood) inline_ref {
    return begin_cell()
        .store_hash(public_key)
        .store_uint(flood, 8);
}

_ unpack_owner_info(slice cs) inline_ref {
    return (cs~load_hash(), cs~load_uint(8));
}



;; =============== utils =============================

(int, int) check_signatures(cell owner_infos, cell signatures, int hash, int cnt_bits) inline_ref {
    int cnt = 0;

    do {
        slice cs = signatures.begin_parse();
        slice signature = cs~load_bits(512);
        int i = cs~load_uint(8);
        signatures = cs~load_dict();

        (slice owner_info, var found?) = owner_infos.udict_get?(8, i);
        throw_unless(ERROR::PUBLIC_KEY_NOT_FOUND, found?);
        throw_unless(ERROR::INVALID_SIGNATURE, check_signature(hash, signature, owner_info.preload_uint(256)));

        int mask = (1 << i);
        int old_cnt_bits = cnt_bits;
        cnt_bits |= mask;
        int should_check = cnt_bits != old_cnt_bits;
        cnt -= should_check;

    } until (cell_null?(signatures));
    return (cnt, cnt_bits);
}


;; =============== common multisig utils =============================

(cell, ()) dec_flood(cell owner_infos, int creator_i) inline_ref {
    (slice owner_info, _) = owner_infos.udict_get?(8, creator_i);
    (int public_key, int flood) = unpack_owner_info(owner_info);
    owner_infos~udict_set_builder(8, creator_i, pack_owner_info(public_key, flood - 1));
    return (owner_infos, ());
}

() cleanup_queries(int bound, int need_save) impure inline_ref {
    bound -= (60 << 32); ;; clean up records expired more than 60 seconds ago
    do {
        var (pending_queries', i, query, f) = pending_queries.udict_delete_get_min(64);
        f~touch();
        if (f) {
            f = (i < bound);
        }
        if (f) {
            if (query~load_int(1)) {
                owner_infos~dec_flood(query~load_uint(8));
            }
            pending_queries = pending_queries';
            need_save = TRUE;
        }
    } until (~ f);

    if (need_save) {
        save_data();
    }
}

(int, int, int, slice) unpack_query_data(slice in_msg, int n, slice query, var found?, int root_i) inline_ref {
    if (found?) {
        throw_unless(ERROR::QUERY_HAS_ALREADY_BEEN_COMPLETED, query~load_bool());
        (int creator_i, int cnt, int cnt_bits, slice msg) = (query~load_uint(8), query~load_uint(8), query~load_uint(n), query);
        throw_unless(ERROR::MSG_DOESNT_MATCH, slice_hash(msg) == slice_hash(in_msg));
        return (creator_i, cnt, cnt_bits, msg);
    }
    throw_unless(ERROR::INVALID_REF_FORMAT, slice_refs(in_msg) * 8 == slice_bits(in_msg));
    return (root_i, 0, 0, in_msg);
}

(cell, cell) update_pending_queries(cell pending_queries, cell owner_infos, slice msg, int query_id, int creator_i, int cnt, int cnt_bits, int n, int k) impure inline_ref {
    if (cnt >= k) {
        accept_message();
        while (msg.slice_refs()) {
            var mode = msg~load_uint(8);
            send_raw_message(msg~load_ref(), mode);
        }
        pending_queries~udict_set_builder(64, query_id, begin_cell().store_bool(FALSE));
        owner_infos~dec_flood(creator_i);
    } else {
        pending_queries~udict_set_builder(64, query_id, begin_cell()
            .store_bool(TRUE)
            .store_uint(creator_i, 8)
            .store_uint(cnt, 8)
            .store_uint(cnt_bits, n)
            .store_slice(msg));
    }
    return (pending_queries, owner_infos);
}

;; =============== recv =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();

    if (is_bounced(flags)) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    load_data();

    raw_reserve(0, RESERVE_MODE::BOUNCE_ON_ACTION_FAIL | RESERVE_MODE::REGULAR | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

    if (op == ANYONE_OP::CLEANUP) {
        var bound = (now() << 32);
        cleanup_queries(bound, false);

        cell excesses_body = begin_cell()
            .store_op_and_query_id(ANYONE_OP::EXCESSES, query_id)
            .end_cell();
        send_msg(sender_address, 0, excesses_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS + SEND_MODE::CARRY_ALL_BALANCE);
        return ();
    }

    if (op == ANYONE_OP::EXCESSES) {
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}

() recv_external(slice in_msg) impure {
    ;; empty message triggers init
    if (slice_empty?(in_msg)) {
        return ();
    }

    ;; Check root signature
    slice root_signature = in_msg~load_bits(512);
    int root_hash = slice_hash(in_msg);
    int root_i = in_msg~load_uint(8);

    load_data();

    (slice owner_info, var found?) = owner_infos.udict_get?(8, root_i);
    throw_unless(ERROR::SENDER_PUBLIC_KEY_NOT_FOUND, found?);
    (int public_key, int flood) = unpack_owner_info(owner_info);
    throw_unless(ERROR::INVALID_SENDER_SIGNATURE, check_signature(root_hash, root_signature, public_key));

    cell signatures = in_msg~load_dict();

    var hash = slice_hash(in_msg);
    int query_wallet_id = in_msg~load_uint(32);
    throw_unless(ERROR::WALLET_ID_DOES_NOT_MATCH, query_wallet_id == wallet_id);

    int query_id = in_msg~load_query_id();

    (_, int msg_bits, _) = slice_compute_data_size(in_msg, 8);
    throw_if(ERROR::INVALID_MESSAGE_FORMAT, msg_bits > 2048);

    (slice query, var found?) = pending_queries.udict_get?(64, query_id);

    ifnot (found?) {
        flood += 1;
        throw_if(ERROR::EXCEEDED_MAX_FLOOD, flood > MAX_FLOOD);
    }

    var bound = (now() << 32);
    throw_if(ERROR::INVALID_QUERY_ID, query_id < bound);
    throw_if(ERROR::INVALID_QUERY_ID, query_id > (bound + (TIME::MAX_DELAY_FOR_QUERY_ID << 32)));

    (int creator_i, int cnt, int cnt_bits, slice msg) = unpack_query_data(in_msg, n, query, found?, root_i);
    int mask = 1 << root_i;
    throw_if(ERROR::ALREADY_SIGNED, cnt_bits & mask);
    cnt_bits |= mask;
    cnt += 1;

    set_gas_limit(1000000);

    ifnot (found?) {
        owner_infos~udict_set_builder(8, root_i, pack_owner_info(public_key, flood));
    }

    (pending_queries, owner_infos) = update_pending_queries(pending_queries, owner_infos, msg, query_id, creator_i, cnt, cnt_bits, n, k);
    save_data();

    commit();

    int need_save = FALSE;
    ifnot (cell_null?(signatures) | (cnt >= k)) {
        (int new_cnt, cnt_bits) = check_signatures(owner_infos, signatures, hash, cnt_bits);
        cnt += new_cnt;
        (pending_queries, owner_infos) = update_pending_queries(pending_queries, owner_infos, msg, query_id, creator_i, cnt, cnt_bits, n, k);
        need_save = TRUE;
    }

    accept_message();

    cleanup_queries(bound, need_save);
}


;; =============== getters =============================

cell get_public_keys() method_id {
    load_data();
    return owner_infos;
}

(int, int) get_n_k() method_id {
    load_data();
    return (n, k);
}

(int, int, int, cell, cell) get_full_data() method_id {
    load_data();
    return (
        wallet_id,
        n,
        k,
        owner_infos,
        pending_queries
    );
}

(int, cell) get_pending_queries() method_id {
    load_data();
    return (n, pending_queries);
}
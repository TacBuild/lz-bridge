;; =============== Jetton Wallet =====================

#include "imports/ccl_utils.fc";
#include "imports/stdlib.fc";
#include "imports/utils.fc";
#include "imports/jetton_utils.fc";
#include "imports/jetton_gas.fc";
#include "imports/messages.fc";


;; =============== CONSTS =============================

;; ops
const OP::INTERNAL_TRANSFER = 0x178d4519;
const OP::BURN_NOTIFICATION = 0x7bdd97de;
const OP::TRANSFER = 0xf8a7ea5;
const OP::TRANSFER_NOTIFICATION = 0x7362d09c;
const OP::EXCESSES = 0xd53276db;
const OP::BURN = 0x595f07bc;
const OP::RETURN_TON = 0x054fa365;

;; errors
const ERROR::NOT_FROM_JETTON_MASTER = 704;
const ERROR::NOT_FROM_OWNER = 705;
const ERROR::INSUFFICIENT_JETTON_BALANCE = 706;
const ERROR::NOT_FROM_JETTON_MASTER_OR_WALLET = 707;
const ERROR::EMPTY_FORWARD_PAYLOAD = 708;
const ERROR::WRONG_OP = 709;
const ERROR::INVALID_RECEIVER_ADDRESS = 710;

;; global
global int balance;
global slice owner_address;
global slice jetton_master_address;


;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    balance = ds~load_coins();
    owner_address = ds~load_msg_addr();
    jetton_master_address = ds~load_msg_addr();
}

() save_data() impure inline {
    set_data(pack_jetton_wallet_data(balance, owner_address, jetton_master_address));
}

;; =============== UTILS =====================

() check_either_forward_payload(slice s) impure inline {
    if (s.preload_uint(1)) {
        ;; forward_payload in ref
        (int remain_bits, int remain_refs) = slice_bits_refs(s);
        throw_unless(ERROR::EMPTY_FORWARD_PAYLOAD, (remain_refs == 1) & (remain_bits == 1)); ;; we check that there is no excess in the slice
    }
    ;; else forward_payload in slice - arbitrary bits and refs
}

() send_tokens(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure inline_ref {
    int query_id = in_msg_body~load_query_id();
    int jetton_amount = in_msg_body~load_coins();
    slice to_owner_address = in_msg_body~load_msg_addr();
    force_basechain(to_owner_address);
    load_data();
    balance -= jetton_amount;

    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(owner_address, sender_address));
    throw_unless(ERROR::INSUFFICIENT_JETTON_BALANCE, balance >= 0);

    cell state_init = calculate_jetton_wallet_state_init(to_owner_address, jetton_master_address, my_code());
    slice to_wallet_address = calculate_address_by_state_init(BASECHAIN, state_init);
    slice response_address = in_msg_body~load_msg_addr();
    in_msg_body~skip_maybe_ref(); ;; custom_payload
    int forward_ton_amount = in_msg_body~load_coins();
    check_either_forward_payload(in_msg_body);

    var msg_body = begin_cell()
    .store_op_and_query_id(OP::INTERNAL_TRANSFER, query_id)
    .store_coins(jetton_amount)
    .store_slice(owner_address)
    .store_slice(response_address)
    .store_coins(forward_ton_amount)
    .store_slice(in_msg_body);

    check_amount_is_enough_to_transfer(msg_value, forward_ton_amount, fwd_fee);

    send_message_with_state_init_and_body(to_wallet_address, 0, state_init, msg_body, FLAGS::BOUNCEABLE, SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE::BOUNCE_ON_ACTION_FAIL);

    save_data();
}

() receive_tokens(slice in_msg_body, slice sender_address, int my_ton_balance, int msg_value) impure inline_ref {
    ;; NOTE we can not allow fails in action phase since in that case there will be
    ;; no bounce. Thus check and throw in computation phase.
    load_data();
    int query_id = in_msg_body~load_query_id();
    int jetton_amount = in_msg_body~load_coins();
    balance += jetton_amount;
    slice from_address = in_msg_body~load_msg_addr();
    slice response_address = in_msg_body~load_msg_addr();
    throw_unless(ERROR::NOT_FROM_JETTON_MASTER_OR_WALLET,
        equal_slices_bits(jetton_master_address, sender_address)
        |
        equal_slices_bits(calculate_user_jetton_wallet_address(from_address, jetton_master_address, my_code()), sender_address)
    );
    int forward_ton_amount = in_msg_body~load_coins();

    if (forward_ton_amount) {
        var msg_body = begin_cell()
        .store_op_and_query_id(OP::TRANSFER_NOTIFICATION, query_id)
        .store_coins(jetton_amount)
        .store_slice(from_address)
        .store_slice(in_msg_body);

        send_message_with_only_body(owner_address, forward_ton_amount, msg_body, FLAGS::BOUNCEABLE, SEND_MODE::PAY_FEES_SEPARATELY | SEND_MODE::BOUNCE_ON_ACTION_FAIL);
    }

    if (~ is_address_none(response_address)) {
        int to_leave_on_balance = my_ton_balance - msg_value + my_storage_due();
        raw_reserve(max(to_leave_on_balance, calculate_jetton_wallet_min_storage_fee()), RESERVE_MODE::AT_MOST);
        send_message_with_only_body(response_address, 0, begin_cell().store_op_and_query_id(OP::EXCESSES, query_id), FLAGS::NON_BOUNCEABLE, SEND_MODE::CARRY_ALL_BALANCE | SEND_MODE::IGNORE_ERRORS);
    }

    save_data();
}

() burn_tokens(slice in_msg_body, slice sender_address, int msg_value, int fwd_fee) impure inline_ref {
    load_data();
    int query_id = in_msg_body~load_query_id();
    int jetton_amount = in_msg_body~load_coins();
    slice receiver_address = in_msg_body~load_msg_addr();
    cell custom_payload = in_msg_body~load_maybe_ref();

    int empty_payload? = cell_null?(custom_payload);
    slice custom_payload_slice = empty_payload? ? null() : custom_payload.begin_parse();
    int crosschain_ton_amount = empty_payload? ? 0 : custom_payload_slice~load_coins();
    cell fee_data = empty_payload? ? null() : custom_payload_slice~load_maybe_ref();
    cell crosschain_payload = empty_payload? ? null() : custom_payload_slice~load_maybe_ref();

    balance -= jetton_amount;
    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(owner_address, sender_address));
    throw_unless(ERROR::INSUFFICIENT_JETTON_BALANCE, balance >= 0);

    var msg_body = begin_cell()
    .store_op_and_query_id(OP::BURN_NOTIFICATION, query_id)
    .store_coins(jetton_amount)
    .store_slice(owner_address)
    .store_slice(is_address_none(receiver_address) ? owner_address : receiver_address)
    .store_maybe_ref(begin_cell()
                    .store_coins(crosschain_ton_amount)
                    .store_maybe_ref(fee_data)
                    .store_maybe_ref(crosschain_payload)
                    .end_cell())
    .end_cell();

    check_amount_is_enough_to_burn(msg_value, fwd_fee, crosschain_ton_amount);

    send_msg(jetton_master_address, 0, msg_body, FLAGS::BOUNCEABLE, SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE | SEND_MODE::BOUNCE_ON_ACTION_FAIL);

    save_data();
}

() on_bounce(slice in_msg_body) impure {
    in_msg_body~skip_bounced_prefix();
    load_data();
    int op = in_msg_body~load_op();
    throw_unless(ERROR::WRONG_OP, (op == OP::INTERNAL_TRANSFER) | (op == OP::BURN_NOTIFICATION));
    in_msg_body~skip_query_id();
    int jetton_amount = in_msg_body~load_coins();
    balance += jetton_amount;
    save_data();
}


;; =============== RECV =====================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }

    slice in_msg_full_slice = in_msg_full.begin_parse();
    int msg_flags = in_msg_full_slice~load_msg_flags();
    if (is_bounced(msg_flags)) {
        on_bounce(in_msg_body);
        return ();
    }
    slice sender_address = in_msg_full_slice~load_msg_addr();
    int fwd_fee_from_in_msg = in_msg_full_slice~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(BASECHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of forward_payload costs

    int op = in_msg_body~load_op();

    if (op == OP::TRANSFER) {
        ;; outgoing transfer
        send_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }

    if (op == OP::INTERNAL_TRANSFER) {
        ;; incoming transfer
        receive_tokens(in_msg_body, sender_address, my_balance, msg_value);
        return ();
    }

    if (op == OP::BURN) {
        burn_tokens(in_msg_body, sender_address, msg_value, fwd_fee);
        return ();
    }

    if (op == OP::RETURN_TON) {
        ;; return ton to owner
        load_data();
        raw_reserve(calculate_jetton_wallet_min_storage_fee(), RESERVE_MODE::REGULAR);
        send_msg(owner_address, 0, null(), FLAGS::NON_BOUNCEABLE, SEND_MODE::CARRY_ALL_BALANCE + SEND_MODE::IGNORE_ERRORS);
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}


;; =============== GETTERS =====================

(int, slice, slice, cell) get_wallet_data() method_id {
    load_data();
    return (balance, owner_address, jetton_master_address, my_code());
}

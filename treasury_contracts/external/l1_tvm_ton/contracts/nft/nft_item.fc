#include "../imports/ccl_utils.fc";
#include "../imports/fee_utils.fc";
#include "../imports/messages.fc";
#include "../imports/nft_gas.fc";
#include "../imports/nft_utils.fc";
#include "../imports/stdlib.fc";
#include "../imports/utils.fc";

;; =============== CONSTS =============================

;; owner ops
const int OWNER_OP::TRANSFER = 0x5fcc3d14;
const int OWNER_OP::BURN = 0x3b390ce;

;; collection ops
const int COLLECTION_OP::INIT = 0xbd6ea770;

;; anyone ops
const int ANYONE_OP::GET_STATIC_DATA = 0x2fcb26a2;

;; nft item ops
const int NFT_ITEM_OP::REPORT_STATIC_DATA = 0x8b771735;
const int NFT_ITEM_OP::OWNERSHIP_ASSIGNED = 0x05138d91;
const int NFT_ITEM_OP::EXCESSES = 0xd53276db;

;; ccl ops
const int CCL_OP::TVM_MSG_TO_EVM = 0x6c582059;
const int CCL_OP::ERROR_NOTIFICATION = 0xae7df95b;

;; operation type
const int OPERATION::NFT_ITEM_BURN = 0xbcd19310;

;; errors
const int ERROR::ALREADY_INITIALIZED = 200;
const int ERROR::NOT_INITIALIZED = 201;
const int ERROR::DESTINATION_NOT_ALLOWED = 202;
const int ERROR::WRONG_OP = 203;

const int ERROR::NOT_FROM_CCL = 70;
const int ERROR::NOT_FROM_OWNER = 71;
const int ERROR::NOT_FROM_COLLECTION = 72;

;; globals
global int init?;
global int index;
global slice collection_address;
global slice owner_address;
global cell content;
global slice ccl_address;

;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    ;; from state init
    init? = ds~load_bool();
    index = ds~load_nft_index();
    slice addresses = (ds~load_ref()).begin_parse();
    collection_address = addresses~load_msg_addr();
    ccl_address = addresses~load_msg_addr();
    owner_address = addresses~load_msg_addr();
    ;; from deploy msg
    content = ds~load_maybe_ref();
}

() save_data() impure {
    set_data(
        begin_cell()
            .store_bool(init?)
            .store_nft_index(index)
            .store_ref(
                begin_cell()
                .store_slice(collection_address)
                .store_slice(ccl_address)
                .store_slice(owner_address)
                .end_cell()
            )
            .store_maybe_ref(content)
            
            .end_cell()
    );
}

;; =============== UTILS =============================

() transfer_ownership(int msg_value, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {
    throw_unless(ERROR::NOT_INITIALIZED, init?);
    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(sender_address, owner_address));

    slice new_owner = in_msg_body~load_msg_addr();
    force_basechain(new_owner);

    slice response_destination = in_msg_body~load_msg_addr();

    in_msg_body~load_bool(); ;; this nft doesn't use custom_payload
    int forward_amount = in_msg_body~load_coins();

    int need_response = ~ is_address_none(response_destination);

    check_amount_is_enough_to_transfer(msg_value, forward_amount, fwd_fees);

    if (forward_amount) {
        cell forward_message = begin_cell()
            .store_op_and_query_id(NFT_ITEM_OP::OWNERSHIP_ASSIGNED, query_id)
            .store_slice(owner_address)
            .store_slice(in_msg_body)
            .end_cell();
        send_msg(new_owner, forward_amount, forward_message, FLAGS::NON_BOUNCEABLE, SEND_MODE::PAY_FEES_SEPARATELY);
    }

    if (need_response) {
        force_basechain(response_destination);
        cell response_message = begin_cell().store_op_and_query_id(NFT_ITEM_OP::EXCESSES, query_id).end_cell();

        raw_reserve(calculate_nft_item_min_storage_fee(), RESERVE_MODE::AT_MOST | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);
        send_msg(response_destination, 0, response_message, FLAGS::NON_BOUNCEABLE, SEND_MODE::CARRY_ALL_BALANCE);
    }

    owner_address = new_owner;

    save_data();
}

() burn(int msg_value, slice sender_address, int query_id, slice in_msg_body, int fwd_fees) impure inline {
    throw_unless(ERROR::NOT_INITIALIZED, init?);
    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(sender_address, owner_address));

    (slice response_address, int crosschain_ton_amount , cell fee_data, cell crosschain_payload) = in_msg_body~load_ccl_data();
    (int is_round_trip, int protocol_fee, int tac_executors_fee, int ton_executors_fee) = parse_fee_data(fee_data);

    int to_ccl? = equal_slices_bits(response_address, ccl_address);

    check_amount_is_enough_to_burn(msg_value, crosschain_ton_amount, fwd_fees, protocol_fee, tac_executors_fee, ton_executors_fee);
    
    builder msg_body = to_ccl? 
    ? begin_cell()
    .store_ccl_data(query_id, OPERATION::NFT_ITEM_BURN, crosschain_ton_amount, owner_address, fee_data)
    .store_slice(owner_address)
    .store_maybe_ref(crosschain_payload)
    : begin_cell()
    .store_op_and_query_id(NFT_ITEM_OP::EXCESSES, query_id)
    .store_maybe_ref(crosschain_payload);

    init? = FALSE;
    save_data();

    if (to_ccl?) {
        ;; reserve for error notification case
        raw_reserve(calculate_nft_item_min_storage_fee(), RESERVE_MODE::AT_MOST | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);
    } ;; else nft burn means nft is no longer exist


    send_message_with_only_body(
        response_address, 
        0,
        msg_body,
        to_ccl? ? FLAGS::BOUNCEABLE : FLAGS::NON_BOUNCEABLE,
        to_ccl? ? SEND_MODE::BOUNCE_ON_ACTION_FAIL | SEND_MODE::CARRY_ALL_BALANCE : SEND_MODE::IGNORE_ERRORS | SEND_MODE::CARRY_ALL_BALANCE
    );
}

;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    slice cs = in_msg_full.begin_parse();

    int msg_flags = cs~load_msg_flags();
    
    if (is_bounced(msg_flags)) {
        ;; restore nft after unsuccessful burn
        load_data();
        in_msg_body~skip_bounced_prefix();
        int op = in_msg_body~load_op();
        throw_unless(ERROR::WRONG_OP, op == CCL_OP::TVM_MSG_TO_EVM);
        init? = TRUE;
        save_data();
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int fwd_fee = cs~retrieve_fwd_fee();

    load_data();

    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (op == COLLECTION_OP::INIT) {
        throw_unless(ERROR::ALREADY_INITIALIZED, ~ init?);
        throw_unless(ERROR::NOT_FROM_COLLECTION, equal_slices_bits(collection_address, sender_address));
        owner_address = in_msg_body~load_msg_addr();
        content = in_msg_body~load_ref();
        init? = TRUE;
        save_data();
        return ();
    }

    if (op == OWNER_OP::TRANSFER) {
        transfer_ownership(msg_value, sender_address, query_id, in_msg_body, fwd_fee);
        return ();
    }

    if (op == ANYONE_OP::GET_STATIC_DATA) {
        throw_unless(ERROR::NOT_INITIALIZED, init?);
        cell msg = begin_cell()
            .store_op_and_query_id(NFT_ITEM_OP::REPORT_STATIC_DATA, query_id)
            .store_nft_index(index)
            .store_slice(collection_address)
            .end_cell();
        send_msg(sender_address, 0, msg, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS | SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE);
        return ();
    }

    if (op == OWNER_OP::BURN) {
        burn(msg_value, sender_address, query_id, in_msg_body, fwd_fee);
        return ();
    }

    if (op == CCL_OP::ERROR_NOTIFICATION) {
        throw_unless(ERROR::ALREADY_INITIALIZED, ~ init?);
        throw_unless(ERROR::NOT_FROM_CCL, equal_slices_bits(sender_address, ccl_address));
        init? = TRUE; ;; all other data is already in the state
        save_data();
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}

;; =============== GETTERS =============================

(int, int, slice, slice, cell) get_nft_data() method_id {
    load_data();
    if (init?) {
        return (init?, index, collection_address, owner_address, content);
    }
    return (init?, index, collection_address, address_none(), null());
}

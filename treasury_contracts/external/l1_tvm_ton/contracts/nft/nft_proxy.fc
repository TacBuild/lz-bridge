;; =============== CrossChainLayer NFT Proxy Contract =====================

#include "../imports/ccl_utils.fc";
#include "../imports/fee_utils.fc";
#include "../imports/stdlib.fc";
#include "../imports/utils.fc";
#include "../imports/precompiled_gas_const/nft_proxy_gas_utils.fc";

#pragma version >=0.4.0;


;; =============== CONSTS =============================

const OPERATION::NFT_ITEM_TRANSFER = 0x8b092962;

;; admin ops
const ADMIN_OP::CHANGE_ADMIN_ADDRESS = 0x581879bc;
const ADMIN_OP::UPDATE_CODE = 0x20faec53;

;; cross chain layer ops
const CCL_OP::EVM_MSG_TO_TVM_PROXY = 0x7817b330;
const CCL_OP::ERROR_NOTIFICATION = 0xae7df95b;
const CCL_OP::TVM_MSG_TO_EVM = 0x6c582059;

;; NFT item ops
const NFT_ITEM_OP::OWNERSHIP_ASSIGNED = 0x05138d91;
const NFT_ITEM_OP::BURN = 0x6656d267;
const NFT_ITEM_OP::TRANSFER = 0x5fcc3d14;

;; errors
const ERROR::NOT_FROM_CROSS_CHAIN_LAYER = 70;
const ERROR::NOT_FROM_ADMIN = 71;

const ERROR::INVALID_PAYLOAD = 200;

;; globals
global slice ccl_address;
global slice admin_address;

;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    ccl_address = ds~load_msg_addr();
    admin_address = ds~load_msg_addr();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(ccl_address)
            .store_slice(admin_address)
            .end_cell()
    );
}

;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();

    if (is_bounced(flags)) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int fwd_fee_from_in_msg = cs~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(BASECHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of crosschain_payload costs

    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    int ton_balance_before_msg = my_balance - msg_value;
    int min_storage_fee = calculate_nft_proxy_min_storage_fee();
    int storage_fee = min_storage_fee - min(ton_balance_before_msg, min_storage_fee);
    msg_value -= storage_fee;

    load_data();

    if (op == CCL_OP::ERROR_NOTIFICATION) {
        throw_unless(ERROR::NOT_FROM_CROSS_CHAIN_LAYER, equal_slices_bits(sender_address, ccl_address));
        
        in_msg_body~skip_bits(32);
        slice item_address = in_msg_body~load_msg_addr();
        slice owner = in_msg_body~load_msg_addr();

        cell msg_body = begin_cell()
            .store_op_and_query_id(NFT_ITEM_OP::TRANSFER, query_id)
            .store_slice(owner)
            .store_slice(owner)
            .store_bool(FALSE) ;; custom payload
            .store_coins(0)
            .store_bool(FALSE) ;; forward payload
            .end_cell();
        
        send_msg(item_address, 0, msg_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::BOUNCE_ON_ACTION_FAIL | SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE);

        return ();
    }

    if (op == CCL_OP::EVM_MSG_TO_TVM_PROXY) {
        throw_unless(ERROR::NOT_FROM_CROSS_CHAIN_LAYER, equal_slices_bits(sender_address, ccl_address));

        slice item_address = in_msg_body~load_msg_addr();
        slice new_owner = in_msg_body~load_msg_addr();
        int forward_amount = in_msg_body~load_coins();

        cell msg_body = begin_cell()
        .store_op_and_query_id(NFT_ITEM_OP::TRANSFER, query_id)
        .store_slice(new_owner)
        .store_slice(new_owner)
        .store_bool(FALSE) ;; custom payload
        .store_coins(forward_amount)
        .store_bool(FALSE) ;; forward payload
        .end_cell();

        raw_reserve(storage_fee, RESERVE_MODE::AT_MOST | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

        send_msg(item_address, 0, msg_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS | SEND_MODE::CARRY_ALL_BALANCE);

        return ();
    }

    if (op == NFT_ITEM_OP::OWNERSHIP_ASSIGNED) {
        (slice item_owner, int crosschain_ton_amount, cell fee_data, cell evm_data) = in_msg_body~load_ccl_data();
        (int is_round_trip, int protocol_fee, int tac_executors_fee, int ton_executors_fee) = parse_fee_data(fee_data);

        int enough_msg_value? = msg_value >= calculate_proxy_tvm_msg_to_evm_fee(fwd_fee, crosschain_ton_amount, protocol_fee, tac_executors_fee, ton_executors_fee);

        if ((~ cell_null?(evm_data)) & enough_msg_value?) {
            cell msg_body = begin_cell()
            .store_ccl_data(query_id, OPERATION::NFT_ITEM_TRANSFER, crosschain_ton_amount, item_owner, fee_data)
            .store_slice(sender_address) ;; NFT Item adress for logs
            .store_slice(item_owner) ;; NFT Item owner for logs
            .store_ref(evm_data)
            .end_cell();

            raw_reserve(storage_fee, RESERVE_MODE::AT_MOST | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

            send_msg(ccl_address, 0, msg_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS | SEND_MODE::CARRY_ALL_BALANCE);
        } else {
            cell msg_body = begin_cell()
            .store_op_and_query_id(NFT_ITEM_OP::TRANSFER, query_id)
            .store_slice(item_owner)
            .store_slice(item_owner)
            .store_bool(FALSE) ;; custom payload
            .store_coins(0)
            .store_bool(FALSE) ;; forward payload
            .end_cell();
            send_msg(sender_address, 0, msg_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::BOUNCE_ON_ACTION_FAIL | SEND_MODE::CARRY_ALL_REMAINING_MESSAGE_VALUE);
            commit();
            throw(enough_msg_value? ? ERROR::INVALID_PAYLOAD : ERROR::NOT_ENOUGH_TON);
        }

        return ();
    }

    if (op == ADMIN_OP::UPDATE_CODE){
        throw_unless(ERROR::NOT_FROM_ADMIN, equal_slices_bits(sender_address, admin_address));
        var new_code = in_msg_body~load_ref();
        set_code(new_code);
        set_c3(new_code.begin_parse().bless());
        return ();
    }

    if (op == ADMIN_OP::CHANGE_ADMIN_ADDRESS){
        throw_unless(ERROR::NOT_FROM_ADMIN, equal_slices_bits(sender_address, admin_address));
        admin_address = in_msg_body~load_msg_addr();
        save_data();
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}

;; =============== GETTERS =============================

(_) get_full_data() method_id {
    load_data();
    return (ccl_address, admin_address);
}
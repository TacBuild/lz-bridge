#include "../imports/content_utils.fc";
#include "../imports/messages.fc";
#include "../imports/nft_utils.fc";
#include "../imports/stdlib.fc";
#include "../imports/utils.fc";
#include "../imports/precompiled_gas_const/nft_gas_utils.fc";

;; =============== CONSTS =============================

const int UNORDERED_COLLECTION_IDENTIFICATOR = -1;

;; collection ops
const int COLLECTION_OP::INIT = 0xbd6ea770;

;; owner ops
const int OWNER_OP::DEPLOY_NFT_ITEM = 0xfdba5d5f;
const int OWNER_OP::BATCH_DEPLOY_NFT_ITEMS = 0x909d579b;
const int OWNER_OP::CHANGE_OWNER = 0x3ac3e0ca;

;; errors
const int ERROR::NOT_FROM_OWNER = 71;

;; globals
global slice owner_address;
global cell content;
global cell nft_item_code;
global slice original_address;

;; =============== STORAGE =============================

() load_data() impure inline {
  var ds = get_data().begin_parse();

  owner_address = ds~load_msg_addr();
  content = ds~load_ref();
  nft_item_code = ds~load_ref();
  original_address = ds;
}

() save_data() impure inline {
  set_data(begin_cell()
    .store_slice(owner_address)
    .store_ref(content)
    .store_ref(nft_item_code)
    .store_slice(original_address)
    .end_cell()
  );
}

;; =============== UTILS =============================

() deploy_nft_item(int query_id, int item_index, slice item_owner, cell nft_content) impure inline {
  cell state_init = calculate_nft_item_state_init(item_index, my_address(), owner_address, nft_item_code);
  slice nft_address = calculate_address_by_state_init(BASECHAIN, state_init);

  builder msg_body = begin_cell()
  .store_op_and_query_id(COLLECTION_OP::INIT, query_id)
  .store_slice(item_owner)
  .store_ref(nft_content);

  send_message_with_state_init_and_body(
    nft_address,
    0,
    state_init,
    msg_body,
    FLAGS::BOUNCEABLE,
    SEND_MODE::CARRY_ALL_BALANCE | SEND_MODE::BOUNCE_ON_ACTION_FAIL
  );
}

;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) {
    return ();
  }

  slice cs = in_msg_full.begin_parse();

  int msg_flags = cs~load_msg_flags();
  if (is_bounced(msg_flags)) {
    return ();
  }

  slice sender_address = cs~load_msg_addr();

  (int op, int query_id) = in_msg_body~load_op_and_query_id();

  int ton_balance_before_msg = my_balance - msg_value;
  int min_storage_fee = calculate_nft_collection_min_storage_fee();
  int storage_fee = min_storage_fee - min(ton_balance_before_msg, min_storage_fee);
  msg_value -= storage_fee;

  raw_reserve(storage_fee, RESERVE_MODE::BOUNCE_ON_ACTION_FAIL | RESERVE_MODE::REGULAR | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

  load_data();

  if (op == OWNER_OP::DEPLOY_NFT_ITEM) {
    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(sender_address, owner_address));
    int item_index = in_msg_body~load_nft_index();
    slice item_owner = in_msg_body~load_msg_addr();
    cell item_content = in_msg_body~load_ref();
    cell maybe_new_content = in_msg_body~load_maybe_ref();
    if (~ cell_null?(maybe_new_content)) {
      content = maybe_new_content;
    }
    deploy_nft_item(query_id, item_index, item_owner, item_content);
    save_data();
    return ();
  }

  if (op == OWNER_OP::CHANGE_OWNER) {
    throw_unless(ERROR::NOT_FROM_OWNER, equal_slices_bits(sender_address, owner_address));
    owner_address = in_msg_body~load_msg_addr();
    save_data();
    return ();
  }

  throw(ERROR::UNKNOWN_OP);
}

;; =============== GETTERS =============================

(int, cell, slice) get_collection_data() method_id {
  load_data();
  return (UNORDERED_COLLECTION_IDENTIFICATOR, content, owner_address);
}

slice get_nft_address_by_index(int index) method_id {
  load_data();
  cell state_init = calculate_nft_item_state_init(index, my_address(), owner_address, nft_item_code);
  return calculate_address_by_state_init(BASECHAIN, state_init);
}

cell get_nft_content(int index, cell individual_nft_content) method_id {
  load_data();
  slice cs = content.begin_parse();
  return begin_cell()
    .store_offchain_prefix()
    .store_slice(cs)
    .store_ref(individual_nft_content)
    .end_cell();
}

slice get_original_address() method_id {
  load_data();
  return original_address;
}

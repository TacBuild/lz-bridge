;; =============== Executor Contract =====================

#include "imports/stdlib.fc";
#include "imports/utils.fc";
#include "imports/executor_gas.fc";
#include "imports/precompiled_gas_const/executor_gas_utils.fc";
#pragma version >=0.4.0;


;; =============== CONSTS =============================
;; CrossChainLayer tvm ops
const CCL_OP::EVM_MSG_TO_TVM = 0x0e50d313;
const CCL_OP::ERROR_NOTIFICATION = 0xcf6a5da4;

;; anyone ops
const ANYONE_OP::PROXY_MSG = 0x3b6616c6;
const ANYONE_OP::ERROR_NOTIFICATION = 0xd3a4fb32;

;; errors
const ERROR::NOT_FROM_CCL = 70;

const ERROR::ALREADY_SPENT = 200;
const ERROR::PROOF_IS_NOT_EXOTIC_CELL = 201;
const ERROR::INVALID_PROOF_CELL_TYPE = 202;
const ERROR::INVALID_PROOF = 203;
const ERROR::UNAUTHORIZED_EXECUTOR = 204;

;; global
global slice ccl_address;
global slice last_executor_address;
global int is_spent;
global cell payload;


;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();

    ccl_address = ds~load_msg_addr();
    last_executor_address = ds~load_msg_addr();
    is_spent = ds~load_bool();
    payload = ds~load_ref();
}

() save_data() impure inline {
    set_data(
        begin_cell()
        .store_slice(ccl_address)
        .store_slice(last_executor_address)
        .store_bool(is_spent)
        .store_ref(payload)
        .end_cell()
    );
}


;; =============== UTILS =============================

() check_merkle_proof(cell proof) impure inline_ref  {
    (slice proof_slice, int is_exotic) = proof.begin_parse_exotic();
    throw_unless(ERROR::PROOF_IS_NOT_EXOTIC_CELL, is_exotic);
    throw_unless(ERROR::INVALID_PROOF_CELL_TYPE, proof_slice~load_uint(8) == CELL_TYPE::MERKLE_PROOF);

    cell payload_dict = proof_slice~load_ref();
    (_, int found) = payload_dict.udict_get?(HASH_SIZE, payload.cell_hash());
    throw_unless(ERROR::INVALID_PROOF, found);
}

(cell, cell, slice, int) load_payload_data() impure inline {
    slice payload_slice = payload.begin_parse();

    cell entries_dict = payload_slice~load_dict();
    cell valid_executors = payload_slice~load_dict();
    slice executor_fee_token = payload_slice~load_msg_addr();
    int executor_fee_amount = payload_slice~load_coins();

    return (entries_dict, valid_executors, executor_fee_token, executor_fee_amount);
}

() check_executor(slice executor_address, int msg_value) impure inline {
    (_, cell valid_executors, _, _) = load_payload_data();

    int addr_hash = slice_hash(executor_address);
    (_, int found) = valid_executors.udict_get?(HASH_SIZE, addr_hash);
    throw_unless(ERROR::UNAUTHORIZED_EXECUTOR, found);
}

() on_bounce(slice in_msg_body, int storage_fee) impure inline {
    in_msg_body~skip_bounced_prefix();
    load_data();
    (int op, int query_id) = in_msg_body~load_op_and_query_id();
    throw_unless(ERROR::NOT_BOUNCEABLE_OP, op == CCL_OP::EVM_MSG_TO_TVM);
    slice response_address = last_executor_address;
    is_spent = false;
    last_executor_address = address_none();
    save_data();

    cell revert_body = begin_cell()
    .store_op_and_query_id(CCL_OP::ERROR_NOTIFICATION, query_id)
    .store_ref(payload)
    .store_slice(response_address)
    .end_cell();

    raw_reserve(storage_fee, RESERVE_MODE::AT_MOST + RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

    send_msg(ccl_address, 0, revert_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS + SEND_MODE::CARRY_ALL_BALANCE);
} 


;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();

    load_data();

    int ton_balance_before_msg = my_balance - msg_value;
    int min_storage_fee = calculate_executor_min_storage_fee(payload);
    int storage_fee = min_storage_fee - min(ton_balance_before_msg, min_storage_fee);
    msg_value -= storage_fee;

    if (is_bounced(flags)) {
        on_bounce(in_msg_body, storage_fee);
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int fwd_fee_from_in_msg = cs~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(BASECHAIN, fwd_fee_from_in_msg);

    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    if (op == ANYONE_OP::PROXY_MSG) {
        throw_if(ERROR::ALREADY_SPENT, is_spent);

        check_executor(sender_address, msg_value);

        cell proof = in_msg_body~load_ref();
        slice fee_to_address = in_msg_body~load_msg_addr();
        slice response_address = in_msg_body~load_msg_addr();

        check_merkle_proof(proof);
        check_amount_is_enough_to_proxy(my_balance, fwd_fee, payload);

        cell msg_body = begin_cell()
        .store_op_and_query_id(CCL_OP::EVM_MSG_TO_TVM, query_id)
        .store_slice(fee_to_address)
        .store_ref(proof)
        .store_ref(payload)
        .store_slice(response_address)
        .end_cell();

        raw_reserve(min_storage_fee, RESERVE_MODE::BOUNCE_ON_ACTION_FAIL | RESERVE_MODE::REGULAR);
        send_msg(ccl_address, 0, msg_body, FLAGS::BOUNCEABLE, SEND_MODE::BOUNCE_ON_ACTION_FAIL | SEND_MODE::CARRY_ALL_BALANCE);

        is_spent = true;
        last_executor_address = sender_address;

        save_data();
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}


;; =============== GETTERS =============================

(_) get_full_data() method_id {
    load_data();
    return (
        ccl_address,
        last_executor_address,
        is_spent,
        payload
    );
}

(_) get_check_proof(cell proof) method_id {
    load_data();
    check_merkle_proof(proof);
    return true;
}

(_) get_is_valid_executor(slice executor_addr) method_id {
    load_data();
    (_, cell valid_executors, _, _) = load_payload_data();
    int addr_hash = slice_hash(executor_addr);
    (_, int found) = valid_executors.udict_get?(HASH_SIZE, addr_hash);

    return found;
}

;; =============== CrossChainLayer Jetton Proxy Contract =====================

#include "imports/ccl_utils.fc";
#include "imports/stdlib.fc";
#include "imports/utils.fc";
#include "imports/precompiled_gas_const/jetton_proxy_gas_utils.fc";
#include "imports/fee_utils.fc";
#pragma version >=0.4.0;


;; =============== CONSTS =============================
;; operation type
const OPERATION::JETTON_TRANSFER = 0x2906ab02;

;; jetton wallet ops
const JETTON_WALLET_OP::TRANSFER_NOTIFICATION = 0x7362d09c;

;; admin ops
const ADMIN_OP::CHANGE_ADMIN_ADDRESS = 0x581879bc;
const ADMIN_OP::UPDATE_CODE = 0x20faec53;
const ADMIN_OP::CANCEL_CHANGING_ADMIN_ADDRESS = 0x60094a1b;

const NEW_ADMIN_OP::CONFIRM_CHANGING_ADMIN_ADDRESS = 0x6a4fbe34;

;; cross chain layer ops
const CCL_OP::EVM_MSG_TO_TVM_PROXY = 0x7817b330;
const CCL_OP::ERROR_NOTIFICATION = 0xae7df95b;
const CCL_OP::TVM_MSG_TO_EVM = 0x6c582059;

;; errors
const ERROR::NOT_FROM_CROSS_CHAIN_LAYER = 70;
const ERROR::NOT_FROM_ADMIN = 71;
const ERROR::NOT_FROM_NEW_ADMIN = 72;

const ERROR::NEW_ADMIN_ADDRESS_IS_NONE = 80;

const ERROR::INVALID_PAYLOAD = 200;

global slice ccl_address;
global slice admin_address;
global slice new_admin_address;


;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    ccl_address = ds~load_msg_addr();
    admin_address = ds~load_msg_addr();
    new_admin_address = ds~load_msg_addr();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_slice(ccl_address)
            .store_slice(admin_address)
            .store_slice(new_admin_address)
            .end_cell()
    );
}


;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();

    if (is_bounced(flags)) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int fwd_fee_from_in_msg = cs~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(BASECHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of crosschain_payload costs

    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    load_data();

    ;; calculate storage fees
    int ton_balance_before_msg = my_balance - msg_value;
    int min_storage_fee = calculate_jetton_proxy_min_storage_fee();
    int storage_fee = min_storage_fee - min(ton_balance_before_msg, min_storage_fee);
    msg_value -= storage_fee;

    if (op == JETTON_WALLET_OP::TRANSFER_NOTIFICATION) {
        int received_amount = in_msg_body~load_coins();
        if (received_amount > 0) {
            (slice owner_address, int crosschain_ton_amount, cell fee_data, cell evm_data) = in_msg_body~load_ccl_data();
            (int is_round_trip, int protocol_fee, int tac_executors_fee, int ton_executors_fee) = parse_fee_data(fee_data);

            int enough_msg_value? = msg_value >= calculate_proxy_tvm_msg_to_evm_fee(fwd_fee, crosschain_ton_amount, protocol_fee, tac_executors_fee, ton_executors_fee);

            if ((~ cell_null?(evm_data)) & enough_msg_value?) {
                cell msg_body = begin_cell()
                .store_ccl_data(query_id, OPERATION::JETTON_TRANSFER, crosschain_ton_amount, owner_address, fee_data)
                .store_slice(sender_address);; JettonProxy JettonWallet address for logs
                .store_slice(owner_address) ;; jettons owner address for logs
                .store_coins(received_amount)
                .store_ref(evm_data)
                .end_cell();

                raw_reserve(storage_fee, RESERVE_MODE::AT_MOST | RESERVE_MODE::INCREASE_BY_BALANCE_BEFORE_COMPUTE);

                send_msg(ccl_address, 0, msg_body, FLAGS::NON_BOUNCEABLE, SEND_MODE::IGNORE_ERRORS | SEND_MODE::CARRY_ALL_BALANCE);
            } else {
                send_jettons(sender_address, query_id, owner_address, received_amount, owner_address, 0, null());
                commit();
                throw(enough_msg_value? ? ERROR::INVALID_PAYLOAD : ERROR::NOT_ENOUGH_TON);
            }
        }
        return ();
    }

    if (op == CCL_OP::ERROR_NOTIFICATION){
        throw_unless(ERROR::NOT_FROM_CROSS_CHAIN_LAYER, equal_slices_bits(sender_address, ccl_address));

        in_msg_body~skip_bits(32);
        slice jetton_wallet_address = in_msg_body~load_msg_addr();
        slice owner_address = in_msg_body~load_msg_addr();
        int received_amount = in_msg_body~load_coins();

        send_jettons(jetton_wallet_address, query_id, owner_address, received_amount, owner_address, 0, null());
        return ();
    }

    if (op == CCL_OP::EVM_MSG_TO_TVM_PROXY) {
        throw_unless(ERROR::NOT_FROM_CROSS_CHAIN_LAYER, equal_slices_bits(sender_address, ccl_address));

        slice jetton_wallet_address = in_msg_body~load_msg_addr();
        slice to_owner_address = in_msg_body~load_msg_addr();
        int jetton_amount = in_msg_body~load_coins();
        slice response_address = in_msg_body~load_msg_addr();
        int forward_ton_amount = in_msg_body~load_coins();
        cell forward_payload = in_msg_body~load_maybe_ref();

        send_jettons(jetton_wallet_address, query_id, to_owner_address, jetton_amount, response_address, forward_ton_amount, forward_payload);
        return ();
    }

    if (op == ADMIN_OP::CHANGE_ADMIN_ADDRESS) {
        throw_unless(ERROR::NOT_FROM_ADMIN, equal_slices_bits(sender_address, admin_address));
        new_admin_address = in_msg_body~load_msg_addr();
        throw_if(ERROR::NEW_ADMIN_ADDRESS_IS_NONE, equal_slices_bits(new_admin_address, address_none()));
        save_data();
        return ();
    }

    if (op == ADMIN_OP::CANCEL_CHANGING_ADMIN_ADDRESS) {
        throw_unless(ERROR::NOT_FROM_ADMIN, equal_slices_bits(sender_address, admin_address));
        new_admin_address = address_none();
        save_data();
        return ();
    }

    if (op == NEW_ADMIN_OP::CONFIRM_CHANGING_ADMIN_ADDRESS) {
        throw_unless(ERROR::NOT_FROM_NEW_ADMIN, equal_slices_bits(sender_address, new_admin_address));
        throw_if(ERROR::NEW_ADMIN_ADDRESS_IS_NONE, equal_slices_bits(new_admin_address, address_none()));
        admin_address = new_admin_address;
        new_admin_address = address_none();
        save_data();
        return ();
    }

    if (op == ADMIN_OP::UPDATE_CODE){
        throw_unless(ERROR::NOT_FROM_ADMIN, equal_slices_bits(sender_address, admin_address));
        var new_code = in_msg_body~load_ref();
        set_code(new_code);
        set_c3(new_code.begin_parse().bless());
        var new_data = in_msg_body~load_ref();
        set_data(new_data);
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}

;; =============== GETTERS =============================

(_) get_full_data() method_id {
    load_data();
    return (
        ccl_address,
        admin_address,
        new_admin_address
    );
}

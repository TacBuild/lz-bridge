;; =============== USDT Treasury contract =====================

#include "../external/l1_tvm_ton/contracts/imports/stdlib.fc";

#include "imports/usdt_utils.fc";
#include "../external/l1_tvm_ton/contracts/imports/fee_utils.fc";
#include "../external/l1_tvm_ton/contracts/imports/utils.fc";

#include "imports/precompiled_gas_const/tac_usdt_treasury_gas_utils.fc";

#pragma version >=0.4.0;

;; =============== CONSTS =============================
;; operation type
const OPERATION::BRIDGE_USDT_TO_TAC = 0x1d350b50;
const ANYONE_OP::EXCESSES = 0xd53276db;

;; errors
const ERROR::NOT_ENOUGH_MSG_VALUE = 100;

global cell evm_data;
global slice ccl_jetton_proxy_address;
global slice jetton_master_address;
global cell jetton_wallet_code;
global int ccl_protocol_fee;
global int tac_executors_fee;
global int ton_executors_fee; 
global int jetton_transfer_ton_amount;
global int treasury_fee; ;; for simplification and to not spend own balance

;; =============== STORAGE =============================

() load_data() impure inline {
    slice ds = get_data().begin_parse();
    evm_data = ds~load_ref();
    ccl_jetton_proxy_address = ds~load_msg_addr();
    jetton_master_address = ds~load_msg_addr();
    jetton_wallet_code = ds~load_ref();
    slice fee_data_slice = ds~load_ref().begin_parse();
    ccl_protocol_fee = fee_data_slice~load_coins();
    tac_executors_fee = fee_data_slice~load_coins();
    ton_executors_fee = fee_data_slice~load_coins();
    jetton_transfer_ton_amount = fee_data_slice~load_coins();
    treasury_fee = fee_data_slice~load_coins();
}

() save_data() impure inline {
    set_data(
        begin_cell()
            .store_ref(evm_data)
            .store_slice(ccl_jetton_proxy_address)
            .store_slice(jetton_master_address)
            .store_ref(jetton_wallet_code)
            .store_ref(begin_cell()
                .store_coins(ccl_protocol_fee)
                .store_coins(tac_executors_fee)
                .store_coins(ton_executors_fee)
                .store_coins(jetton_transfer_ton_amount)
                .store_coins(treasury_fee)
                .end_cell())
            .end_cell()
    );
}

;; =============== RECV =============================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_msg_flags();

    if (is_bounced(flags)) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int fwd_fee_from_in_msg = cs~retrieve_fwd_fee();
    int fwd_fee = get_original_fwd_fee(BASECHAIN, fwd_fee_from_in_msg); ;; we use message fwd_fee for estimation of crosschain_payload costs

    (int op, int query_id) = in_msg_body~load_op_and_query_id();

    load_data();

    ;; calculate storage fees
    int ton_balance_before_msg = my_balance - msg_value;
    int min_storage_fee = calculate_usdt_treasury_min_storage_fee();
    int storage_fee = min_storage_fee - min(ton_balance_before_msg, min_storage_fee);
    msg_value -= storage_fee;

    if (op == OPERATION::BRIDGE_USDT_TO_TAC) {
        int usdt_amount = in_msg_body~load_coins();
        cell add_fee = in_msg_body~load_maybe_ref();
        int add_protocol_fee = 0;
        int add_jetton_transfer_ton_amount = 0;

        if (cell_null?(add_fee) == FALSE) {
            slice add_fee_slice = add_fee.begin_parse();
            add_protocol_fee = add_fee_slice~load_coins();
            add_jetton_transfer_ton_amount = add_fee_slice~load_coins();
        }

        slice jetton_wallet_address = calculate_user_usdt_jetton_wallet_address(my_address(), jetton_master_address, jetton_wallet_code);
        cell fee_data = build_fee_data(1, ccl_protocol_fee + add_protocol_fee, tac_executors_fee, ton_executors_fee); ;; set to roundTrip in order to rollback message in case of failure

        cell forward_payload = begin_cell()
            .store_coins(0) ;; crosschain_ton_amount
            .store_maybe_ref(fee_data) ;; fee data for ccl
            .store_maybe_ref(evm_data) ;; evm data call on TAC
            .end_cell();

        int forward_ton_amount = ccl_protocol_fee + tac_executors_fee + ton_executors_fee + jetton_transfer_ton_amount;
        forward_ton_amount += add_protocol_fee + add_jetton_transfer_ton_amount;

        throw_unless(ERROR::NOT_ENOUGH_MSG_VALUE, msg_value >= forward_ton_amount + treasury_fee);

        send_jettons(jetton_wallet_address, query_id, ccl_jetton_proxy_address, usdt_amount, my_address(), forward_ton_amount, forward_payload);

        return ();
    }

    if (op == ANYONE_OP::EXCESSES) {
        return ();
    }

    throw(ERROR::UNKNOWN_OP);
}

;; =============== GETTERS =============================

(_) get_full_data() method_id {
    load_data();

    return (
        evm_data,
        ccl_jetton_proxy_address,
        jetton_master_address,
        jetton_wallet_code,
        ccl_protocol_fee,
        tac_executors_fee,
        ton_executors_fee,
        jetton_transfer_ton_amount,
        treasury_fee
    );
}
